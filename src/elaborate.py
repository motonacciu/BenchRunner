'''
    BenchRunner 
    Copyright (C) 2010  Simone Pellegrini

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

'''

import os, re, configuration, iterator, config_parse

# substite the parameters which have no alternatives. 
def do_manual_substitution(cmd, config):
    prev_cmd = None
    while cmd != prev_cmd:
        prev_cmd = cmd
        for param in config.parameters.values():
            if len(param) == 1 and cmd.find('{'+param.name+'}') != -1:
                cmd = cmd.replace('{'+param.name+'}', str(param.currValue()))
    return cmd

def extract_parameters(cmd):
    p = re.compile('{\w+}')
    param_list = []
    for x in p.findall(cmd):
        assert x[1:-1] not in  param_list, "Parameter %s already in the list" % x[1:-1]
        param_list.append( x[1:-1] )
    return param_list

class Elaborator:
    
    def __init__(self, input_cfg, output_cfg):
        # probably a configuration should be the observer for the parameters
        # and elaborator the observer for the configuration
        for param in input_cfg.parameters:
            param.addObserver(self)
        for param in output_cfg.parameters:
            param.addObserver(self)
        #---------------------------------------------------
        
        self.__in_cfg = input_cfg
        self.__out_cfg = output_cfg
        


def elaborate_data(elaborate, config, invariants):
    print ("==== Starting data elaboration ====")
    # extract the input file name
    input_file = do_manual_substitution(elaborate.input_file.currValue(), config)
    print ("\t*** The skeleton for input files is: %s ***" % input_file) 
    
    dir_skel = os.path.dirname(input_file)
    file_skel = os.path.basename(input_file)
    
    # create an iterator through all the directories spawned by this benchmark
    dc = configuration.Configuration() 
    for param_name in extract_parameters(dir_skel):
        dc += config.parameters[param_name]
    
    fc = configuration.Configuration() 
    for param_name in extract_parameters(file_skel):
        fc += config.parameters[param_name]
        
    # now iterate through all the directories 
    for it in iterator.ConfigIterator(dc, invariants):
        # for each directory we list the files and look for files which have been generated by the benchmark
        curr_dir = dir_skel.format(**it.parameters)
        print ("\t*** Looking up directory: %s ***" % curr_dir)
        for file in os.listdir(curr_dir):
            if not file.startswith('~'):
                # skip raw files
                continue
            print ("\t\t-> Opening file:", file)
            p = re.compile('-{0,1}[a-zA-Z0-9]+')
            file_name_vals = [ config_parse.convert(x.group()) for x in p.finditer(os.path.splitext(file)[0]) ]
            # check number of arguments in file name
            if len(file_name_vals) != len(fc):
                print ('\t\t\t# Wrong number of elements in file name: found %d expected %d #, skipping file!' % 
                       (len(file_name_vals), len(fc)) )
                continue
            
            # if the number of args is correct we now set the configuration values
            i = 0
            for param_name in fc.parameter_keys():
                fc.parameters[param_name].setValue(file_name_vals[i])
                i+=1
            
            
                 
            
